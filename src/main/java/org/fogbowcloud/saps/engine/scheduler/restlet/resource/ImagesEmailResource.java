package org.fogbowcloud.saps.engine.scheduler.restlet.resource;

import org.apache.commons.httpclient.HttpStatus;
import org.apache.log4j.Logger;
import org.fogbowcloud.saps.engine.core.model.ImageTask;
import org.fogbowcloud.saps.engine.core.model.ImageTaskState;
import org.fogbowcloud.saps.engine.core.pojo.ImageTaskFileList;
import org.fogbowcloud.saps.engine.core.service.EmailService;
import org.fogbowcloud.saps.engine.core.service.ProcessedImagesService;
import org.json.JSONArray;
import org.json.JSONException;
import org.restlet.data.Form;
import org.restlet.data.MediaType;
import org.restlet.ext.json.JsonConverter;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.resource.ClientResource;
import org.restlet.resource.Post;
import org.restlet.resource.ResourceException;

import java.io.IOException;
import java.sql.SQLException;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Resource to handle email sending about ImageTasks.
 */
public class ImagesEmailResource extends BaseResource {

    public static final Logger LOGGER = Logger.getLogger(ImagesEmailResource.class);

    private static final int JSONARRAY_TO_STRING_FACTOR = 2;
    private static final String REQUEST_ATTR_PROCESSED_IMAGES = "images_id[]";
    private static final String PROCESSED_TASKS_URN = "/archivedTask";
    private static final String PROCESSED_IMAGES_EMAIL_TITLE = "[SAPS] Filter results";
    private static final String SUCCESSFUL_EMAIL_SENDING_FEEDBACK =
            "Email ser√° enviado em breve.";
    private static final String UNSUCCESSFUL_EMAIL_SENDING_FEEDBACK =
            "Houve um erro ao enviar o email, tente novamente.";
    private static final String RESTLET_HTTP_HEADERS = "org.restlet.http.headers";

    /**
     * Sends information of files generated by execution of ImageTasks that
     * have had its IDs specified via HTTP body.
     *
     * @param representation Representation containing data sent via HTTP body.
     * @return Representation with feedback of email sending.
     */
    @Post
    public Representation sendProcessedImagesToEmail(Representation representation) {
        Form form = new Form(representation);
        String userEmail = form.getFirstValue(UserResource.REQUEST_ATTR_USER_EMAIL, true);
        String userPass = form.getFirstValue(UserResource.REQUEST_ATTR_USERPASS, true);
        if (!authenticateUser(userEmail, userPass) || userEmail.equals("anonymous")) {
            throw new ResourceException(HttpStatus.SC_UNAUTHORIZED);
        }

        String[] imageTasksIds = form.getValuesArray(REQUEST_ATTR_PROCESSED_IMAGES, true);
        try {
            List<ImageTaskFileList> allImageTasksFileList = getImageTaskFileLists(imageTasksIds);
            String emailMessage = generateEmailMessage(allImageTasksFileList);
            Properties properties = application.getProperties();
            EmailService.sendEmail(
                    properties,
                    userEmail,
                    PROCESSED_IMAGES_EMAIL_TITLE,
                    emailMessage);
            return new StringRepresentation(SUCCESSFUL_EMAIL_SENDING_FEEDBACK, MediaType.TEXT_PLAIN);
        } catch (Throwable t) {
            LOGGER.error("Error while sending email of processed images", t);
        }
        return new StringRepresentation(UNSUCCESSFUL_EMAIL_SENDING_FEEDBACK, MediaType.TEXT_PLAIN);
    }

    /**
     * Generates a email message from list of {@link ImageTaskFileList}.
     *
     * @param imageTasksFileLists List of ImageTaskFileList.
     * @return Email message.
     */
    private String generateEmailMessage(List<ImageTaskFileList> imageTasksFileLists) throws JSONException {
        JSONArray emailMessageJSON = generateEmailMessageJSON(imageTasksFileLists);
        try {
            return emailMessageJSON.toString(JSONARRAY_TO_STRING_FACTOR);
        } catch (JSONException e) {
            LOGGER.error("Error while generating String email message from JSON", e);
            throw e;
        }
    }

    /**
     * Generates a email message in form of JSONArray from list of
     * {@link ImageTaskFileList}.
     *
     * @param imageTasksFileLists List of ImageTaskFileList.
     * @return Email message in form of a JSONArray.
     */
    private JSONArray generateEmailMessageJSON(List<ImageTaskFileList> imageTasksFileLists) {
        JSONArray emailMessageJSON = new JSONArray();
        try {
            for (ImageTaskFileList imageTasksFileList: imageTasksFileLists) {
                emailMessageJSON.put(imageTasksFileList.toJSON());
            }
        } catch (JSONException e) {
            LOGGER.error("Error while parsing list of files to JSON of ImageTask", e);
        }
        return emailMessageJSON;
    }

    /**
     * Returns a list of {@link ImageTaskFileList}, each one of these for each
     * {@link ImageTask} that had its ID in specified list of IDs.
     *
     * @param imageTasksIds List of IDs of ImageTasks.
     * @return List of ImageTaskFileList.
     */
    private List<ImageTaskFileList> getImageTaskFileLists(String[] imageTasksIds) throws SQLException {
        try {
            List<ImageTask> imageTasks = application.getImageTasks(imageTasksIds);
            List<ImageTaskFileList> localImageTasksFileLists = getLocalImageTaskFileLists(imageTasks);
            List<ImageTaskFileList> remoteImageTasksFileList = getRemoteImageTaskFileLists(imageTasks);
            List<ImageTaskFileList> allImageTasksFileList = new ArrayList<>();
            allImageTasksFileList.addAll(localImageTasksFileLists);
            allImageTasksFileList.addAll(remoteImageTasksFileList);
            return allImageTasksFileList;
        } catch (SQLException e) {
            LOGGER.error("Error while getting list of ImageTaskFileList to send email", e);
            throw e;
        }
    }

    /**
     * Returns a list of {@link ImageTaskFileList}, each one of these for each
     * local {@link ImageTask} from specified list of ImageTasks.
     *
     * @param imageTasks List of ImageTasks containing local ImageTasks.
     * @return List of ImageTaskFileList.
     */
    private List<ImageTaskFileList> getLocalImageTaskFileLists(List<ImageTask> imageTasks) {
        List<ImageTask> localImageTasks = imageTasks.stream()
                .filter(imageTask -> imageTask.getState().equals(ImageTaskState.ARCHIVED))
                .collect(Collectors.toList());
        return localImageTasks.stream()
                .map(imageTask -> ProcessedImagesService.generateImageTaskFiles(
                        application.getProperties(),
                        imageTask))
                .collect(Collectors.toList());
    }

    /**
     * Returns a list of {@link ImageTaskFileList}, each one of these for each
     * remote {@link ImageTask} from specified list of ImageTasks.
     *
     * @param imageTasks List of ImageTasks containing remote ImageTasks.
     * @return List of ImageTaskFileList.
     */
    private List<ImageTaskFileList> getRemoteImageTaskFileLists(List<ImageTask> imageTasks) {
        List<ImageTask> remoteImageTasks = imageTasks
                .stream()
                .filter(imageTask -> imageTask.getState().equals(ImageTaskState.REMOTELY_ARCHIVED))
                .collect(Collectors.toList());
        Map<String, List<ImageTask>> remoteImageTaskGroupedBySAPSInstanceURL = remoteImageTasks
                .stream()
                .collect(Collectors.groupingBy(ImageTask::getFederationMember));
        return remoteImageTaskGroupedBySAPSInstanceURL
                .entrySet()
                .stream()
                .map(this::getImageTasksFilesFromSAPSNeighbor)
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
    }

    /**
     * Returns a list of {@link ImageTaskFileList} for SAPS neighbor that had
     * it URL specified.
     *
     * @param SAPSNeighborAndImageTasks {@link Map.Entry} that have a SAPS
     *                                  neighbor URL as key and a list of
     *                                  ImageTasks as value.
     * @return List of {@link ImageTaskFileList}.
     */
    private List<ImageTaskFileList> getImageTasksFilesFromSAPSNeighbor(
            Map.Entry<String, List<ImageTask>> SAPSNeighborAndImageTasks) {
        String SAPSNeighborURL = SAPSNeighborAndImageTasks.getKey();
        List<ImageTask> imageTasks = SAPSNeighborAndImageTasks.getValue();
        List<String> imageTasksIds = imageTasks.stream()
                .map(ImageTask::getTaskId)
                .collect(Collectors.toList());
        List<ImageTaskFileList> imageTaskFileLists = new ArrayList<>();
        try {
            ClientResource clientResource = new ClientResource(SAPSNeighborURL + PROCESSED_TASKS_URN);
            for (String imageTaskId: imageTasksIds) {
                clientResource.addQueryParameter(REQUEST_ATTR_PROCESSED_IMAGES, imageTaskId);
            }
            Representation response = clientResource.get(MediaType.APPLICATION_JSON);
            imageTaskFileLists = extractImageTaskFileLists(response);
        } catch (Throwable t) {
            LOGGER.error("Error while getting ImageTaskFileList from SAPS Neighbor.", t);
        }
        return imageTaskFileLists;
    }

    /**
     * Extract a list of {@link ImageTaskFileList} from specified response object.
     *
     * @param response Response containing a list of ImageTaskFileList.
     * @return List of ImageTaskFileList.
     */
    private List<ImageTaskFileList> extractImageTaskFileLists(Representation response)
            throws IOException, JSONException {
        JsonConverter jsonConverter = new JsonConverter();
        JSONArray responseJson = jsonConverter.toObject(response, JSONArray.class, null);
        List<ImageTaskFileList> imageTaskFileLists = new ArrayList<>();
        for (int i = 0; i < responseJson.length(); i++) {
            imageTaskFileLists.add(new ImageTaskFileList(responseJson.optJSONObject(i)));
        }
        return imageTaskFileLists;
    }

}
