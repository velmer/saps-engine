package org.fogbowcloud.saps.engine.scheduler.restlet.resource;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;
import org.fogbowcloud.saps.engine.core.dispatcher.SubmissionParameters;
import org.fogbowcloud.saps.engine.core.model.ImageTask;
import org.fogbowcloud.saps.engine.core.pojo.ImageTaskFileList;
import org.fogbowcloud.saps.engine.core.service.ProcessedImagesService;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.restlet.data.Form;
import org.restlet.data.Header;
import org.restlet.data.MediaType;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.resource.Get;
import org.restlet.resource.Post;
import org.restlet.util.Series;

/**
 * Responsible for retrieve information about already processed {@link ImageTask}.
 */
public class ArchivedTasksResource extends BaseResource {

	private static final Logger LOGGER = Logger.getLogger(ArchivedTasksResource.class);

	private static final String REQUEST_ATTR_PROCESSED_IMAGES = "images_id[]";
	private static final String IMAGETASKS_IDS_SEPARATOR = ",";
	private static final String LIST_OF_IDS_OF_IMAGETASKS_REQUIRED =
			"A lista de IDs das ImageTasks é obrigatória.";

	/**
	 * Returns all processed tasks that matches the execution parameters passed
	 * in {@code representation}.
	 *
	 * @param representation Entity containing execution parameters.
	 * @return List of processed tasks.
	 */
	@Post
	public Representation getProcessedTasksInInterval(Representation representation) {
		Form form = new Form(representation);
		SubmissionParameters submissionParameters = extractSubmissionParameters(form);

		String log = "Recovering processed tasks with settings:\n" +
				"\tLower Left: " + submissionParameters.getLowerLeftLatitude() + ", " + submissionParameters.getLowerLeftLongitude() + "\n" +
				"\tUpper Right: " + submissionParameters.getUpperRightLatitude() + ", " + submissionParameters.getUpperRightLongitude() + "\n" +
				"\tInterval: " + submissionParameters.getInitDate() + " - " + submissionParameters.getEndDate() + "\n" +
				"\tGathering: " + submissionParameters.getInputGathering() + "\n" +
				"\tPreprocessing: " + submissionParameters.getInputPreprocessing() + "\n" +
				"\tAlgorithm: " + submissionParameters.getAlgorithmExecution() + "\n";
		LOGGER.info(log);

		List<ImageTask> tasks = application.searchProcessedTasks(submissionParameters);
		JSONObject resObj = buildJsonResponseFromTaskList(tasks);
		return new StringRepresentation(resObj.toString(), MediaType.APPLICATION_JSON);
	}

    /**
     * Returns the files generated by execution of each {@link ImageTask} that
     * had its ID specified.
     */
	@Get
	public Representation getProcessedImageTasksFiles() {
		String imageTasksIdsParam = getQuery().getValues(REQUEST_ATTR_PROCESSED_IMAGES);
		if (Objects.isNull(imageTasksIdsParam)) {
			return new StringRepresentation(LIST_OF_IDS_OF_IMAGETASKS_REQUIRED, MediaType.TEXT_PLAIN);
		}

		String[] imageTasksIds = imageTasksIdsParam.split(IMAGETASKS_IDS_SEPARATOR);
		LOGGER.info("Recovering files from processed ImageTasks from list of IDs: "
                + Arrays.toString(imageTasksIds));

		List<ImageTaskFileList> imageTaskFileLists = getImageTaskFileLists(imageTasksIds);
		JSONArray imageTaskFileListsJSONArray = parseToJsonArray(imageTaskFileLists);
        return new StringRepresentation(imageTaskFileListsJSONArray.toString(), MediaType.APPLICATION_JSON);
    }

	/**
	 * Gets a list of {@link ImageTaskFileList} given the IDs of {@link ImageTask}.
	 *
	 * @param imageTasksIds IDs of ImageTasks to have its ImageTaskFileList returned.
	 * @return List of {@link ImageTaskFileList}.
	 */
	private List<ImageTaskFileList> getImageTaskFileLists(String[] imageTasksIds) {
		List<ImageTaskFileList> imageTaskFileLists = new ArrayList<>();
		try {
			List<ImageTask> imageTasks = application.getImageTasks(imageTasksIds);
			imageTaskFileLists = imageTasks.stream()
					.map(imageTask -> ProcessedImagesService.generateImageTaskFiles(
							application.getProperties(),
							imageTask))
					.collect(Collectors.toList());
		} catch (SQLException e) {
			LOGGER.error("Error while getting ImageTasks from Catalogue", e);
		}
		return imageTaskFileLists;
	}

	/**
	 * Parses the specified list of {@link ImageTaskFileList} to a {@link JSONArray}.
	 *
	 * @param imageTaskFileLists List of ImageTaskFileList to be parsed.
	 * @return List of ImageTaskFileList parsed to JSONArray.
	 */
	private JSONArray parseToJsonArray(List<ImageTaskFileList> imageTaskFileLists) {
		JSONArray resultJSONArray = new JSONArray();
		try {
            for (ImageTaskFileList imageTaskFileList: imageTaskFileLists) {
                resultJSONArray.put(imageTaskFileList.toJSON());
            }
        } catch (JSONException e) {
            LOGGER.error("Error while parsing list of ImageTaskFileList to JSONArray", e);
        }
		return resultJSONArray;
	}

}